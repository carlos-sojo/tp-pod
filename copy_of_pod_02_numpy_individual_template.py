# -*- coding: utf-8 -*-
"""Copy of POD - 02/NumPy/Individual - TEMPLATE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1R0m-dN64ef0baHCae6h_nPKK7qm6HQAE

[link text](https://)*   **Año:** [2005]
*   **Alumno/a:** [Carlos Sojo]
*   **Legajo:** [95646827]

# NumPy
A continuación, cada celda va a pedir algo distinto. Por favor, realizarlo con la menor cantidad de lineas posibles y con NumPy.

Importar `numpy` con el alias `np` e imprimir la versión instalada.
"""

import numpy as np
print(np.__version__)

"""Setear el "seed" de la librearia en 0."""

np.random.seed(0)

"""Crear un vector vacio (en ingles, *empty*) para subir 100 imagenes de 100x600 pixeles. Imprimir el shape de dicho vector."""

vector=np.empty((100,100,600))
vector.shape

"""Crear dos vectores vacios donde uno tiene 1,000 elementos y el otro tiene 100,000 elementos. Imprimir el tamaño ocupado en memoria de cada arreglo en bytes."""

vector=np.empty(1000)
vector2=np.empty(100000)
vector.nbytes
vector2.nbytes

"""Crear un vector vacío con 10 elementos. El quinto elemento tiene que ser igual a 1. Imprimir el vector."""

vector=np.zeros(10)
vector[4]=1
vector

"""Generar un arreglo con los valores desde 10 hasta 35 en pasos de 2. Imprimir el arreglo."""

import numpy as np

arr = np.arange(10, 36, 2)
print(arr)

"""Generar un arreglo con los valores desde -1 hasta -1 en pasos de 0.25. Luego, revertirlo. Imprimir el arreglo."""

arr=np.arange(-1,1,0.25)[::-1]
arr

"""Generar un arreglo que va desde -10 y 10 y que tenga 2,878 elementos. Imprimir el primer, último y 198º elemento."""

arr=np.linspace(-10,10,2878)
print(arr[0])
print(arr[-1])
print(arr[198])

"""Generar una matriz 5x5 y con valores de 0 a 24. Imprimir la matriz."""

arr=np.arange(25).reshape(5,5)
arr

"""Generar una lista de 10,000 elementos que vengan de una distribucion uniforme entre la constante de euler y π. (Nota: utilizar constantes de `numpy`). Dibujar la distribución con `matplotlib` en forma de histograma e imprimir el tipo de dato del arreglo."""

import numpy as np
import matplotlib.pyplot as plt

data = np.random.uniform(low=np.e, high=np.pi, size=10000)

plt.hist(data, bins=50)
plt.xlabel('Value')
plt.ylabel('Frequency')
plt.title('Uniform Distribution between e and π')
plt.show()

print(data.dtype)

"""Generar una lista de 20 elementos que vengan de una distribucion uniforme entre 0 y 1 e imprimirlo ordenado."""

data = np.random.uniform(low=0, high=1, size=20)
sorted_data = np.sort(data)
print(sorted_data)

"""Lo mismo que el punto anterior pero con una distribución normal con media 160 y desvío estandar 30."""

data = np.random.normal(loc=160, scale=30, size=20)

sorted_data = np.sort(data)

print(sorted_data)

"""Lo mismo que el punto anterior pero con una distribución normal con media 50 y desvío estandar 1. Imprimir el valor mas cercano (es decir, el de menor distancia) a 20 de los números generados."""

data = np.random.normal(loc=50, scale=1, size=20)

closest_value = data[np.argmin(np.abs(data - 20))]

print("Closest value to 20:", closest_value)

"""Teniendo en cuenta la declaración de la siguiente variable, imprimir la suma, la media, el máximo, y el mínimo de sus elementos."""

arreglo_dummy = np.array([1,9,10,23,45,78,94,78,10,23,65,47])

arreglo_dummy = np.array([1, 9, 10, 23, 45, 78, 94, 78, 10, 23, 65, 47])
print("Sum:", np.sum(arreglo_dummy))
print("Mean:", np.mean(arreglo_dummy))
print("Maximum:", np.max(arreglo_dummy))
print("Minimum:", np.min(arreglo_dummy))

"""Hacer lo mismo que el punto anterior pero... con un arreglo particular. Imprimir el resultado y encontrarle una explicación."""

arreglo_weird = np.array([1,9,10,23,45,78,94,np.nan,10,23,65,47])

arreglo_weird = np.array([1, 9, 10, 23, 45, 78, 94, np.nan, 10, 23, 65, 47])

print("Sum:", np.sum(arreglo_weird))
print("Mean:", np.mean(arreglo_weird))
print("Maximum:", np.max(arreglo_weird))
print("Minimum:", np.min(arreglo_weird))

"""Generar un conjunto de 100 numeros ***enteros*** entre 0 y 10. Imprimir la cantidad de numeros pares que se generaron e imprimir el tipo de dato del arreglo."""

lista=np.random.randint(0,11,100)
lista
can=0
for i in lista:
  if i%2!=1:
    can=can+1
print(can)

"""Generar un conjunto de 100 numeros enteros entre 0 y 10. Imprimir la cantidad de numeros mayores a 4 que se generaron."""

data = np.random.randint(0, 11, size=100)

count_greater_than_4 = np.sum(data > 4)

print("Number of values greater than 4:", count_greater_than_4)

"""Generar un conjunto de 100 numeros enteros entre 0 y 10. Imprimir la cantidad de numeros mayores a 6 e impares que se generaron."""

data = np.random.randint(0, 11, size=100)

count = np.sum((data > 6) & (data % 2 != 0))

print("Number of values greater than 6 and odd:", count)

"""Supongamos que hay elecciones nacionales en un país y la cantidad de votos fueron los siguientes:


|Candidato 1|Cantidato 2|Cantidato 3|
|--|--|--|
|1,772,322  |1,102,669|2,100,978 |

Con `numpy`, calcular el porcentaje correspondiente a cada candidato y redondear a 2 dígitos. Imprimir los porcentajes finales y el numero del candidato ganador (aunque sea obvio, responder con lógica de `numpy`).
"""

q1 = 1_772_322
q2= 1_102_669
q3 = 2_100_978
lista=np.array([q1,q2,q3])

suma=np.sum(lista)
porcentaje=(lista/suma)*100
redondeo=np.round(porcentaje,0)

print(redondeo)

ganador=np.argmax(redondeo)
posicion=np.where(redondeo==redondeo[ganador])
print(posicion)

"""Generar un arreglo de 1,000 numeros de una distribución uniforme entre 0 y 1. Luego, generar otro arreglo que contenga todos los numeros del primer arreglo que son mayores a 0.7. Imprimir la media del "sub" arreglo."""

arreglo=np.random.uniform(0,1,1000)
sub = np.array(arreglo>0.7)
arreglo[sub]

"""# Operación vectorizada vs. Operación loopeada
`numpy` no es solo poderoso por la gama de operaciones que podemos hacer en pocas lineas de código. Sino que por su eficiencia.

Supongamos que tenemos la función $f(x)=10*(x^2/e^x)$. Evaluar la función (en celdas apartes) entre -1 y 1 con 100,000 valores (i) con y (ii) sin un loop `for`. Medir tiempos de cada celda y sacar conclusiones.
"""

import time
def f_vectorizada(x):
    return 10 * (x**2 / np.exp(x))

x = np.linspace(-1, 1, 100000)

start_time = time.time()
f_vectorizada(x)

end_time = time.time()
time_vectorizado = end_time - start_time

print(time_vectorizado)

import time

def f_vectorizada(x):
    return 10 * (x**2 / np.exp(x))

lista = np.linspace(-1, 1, 100000)
start_time = time.time()
for i in lista:
  f_vectorizada(i)

end_time = time.time()
time_vectorizado = end_time - start_time
print(time_vectorizado)

"""El resultado de la celda anterior (aprovechar lo obtenido), graficarlo como gráfico de lineas."""

import matplotlib.pyplot as plt
import numpy
values=[]
def f_vectorizada(x):
    return 10 * (x**2 / np.exp(x))

lista = np.linspace(-1, 1, 100)

for i in lista:
  values.append(f_vectorizada(i))


plt.plot(lista, values)

"""# Análisis de imagenes

Matematicamente hablando, las imagenes son arreglos. Si una imagen es de blanco y negro, tenemos una imagen de un canal y puede ser interpretado como una simple matriz (`.shape=2`). Si tiene varios canales, tenemos una matriz asignada para cada canal (`.shape=3`).

[Lenna](https://en.wikipedia.org/wiki/Lenna) es una imagen ampliamente utilizada en ciencias de la computación. Se volvió un icono. La idea va a ser analizar a la imagen y tratarla para varios propositos. Corra la siguiente celda para descargar la imagen y guardala como arreglo `numpy` en la variable `image`. Utilizar esta variable en las siguientes celdas.
"""

!wget https://upload.wikimedia.org/wikipedia/en/7/7d/Lenna_%28test_image%29.png
from PIL import Image
image = Image.open('Lenna_(test_image).png')
image = np.asarray(image)

"""Arranquemos con mostrar la imagen. Para eso, utilice `matplotlib.pyplot`."""

import matplotlib.pyplot as plt
plt.imshow(image)

"""¿Cual es la dimensión de la imagen y que ancho y alto tiene?"""

print(image.shape)

"""Recorte la imagen en ancho entre (tomando como referencia los ejes de la imagen vista anteriormente) los 100 y 350 pixeles y en alto entre 200 y 400 pixeles. Mostrar el resultado."""

rec = image[100:350,200:400]
plt.imshow(rec)

"""Muestre cada uno de los canales de la imagen."""

lena_green=np.copy(image)
lena_green[:,:,0]=0
lena_green[:,:,2]=0
plt.title("Lena_ canal verde")
plt.imshow(lena_green)

lena_blue=np.copy(image)
lena_blue[:,:,0]=0
lena_blue[:,:,1]=0
plt.title("Lena_ canal azul")
plt.imshow(lena_blue)

lena_red=np.copy(image)
lena_red[:,:,1]=0
lena_red[:,:,2]=0
plt.title("Lena_ canal rojo")
plt.imshow(lena_red)

"""Calcule el minimo, el máximo, y el promedio de los valores de la imagen."""

maximo=np.max(image)
minimo=np.min(image)
media=np.mean(image)
print(maximo, minimo ,media)

"""La verdad que tener todos los colores de la imagen es muy redundante. Paselo a blanco y negro. Para ello, tome el promedio de los canales en cada pixel. Muestre la imagen en blanco y negro."""

h,w,c=image.shape

lena_gris=np.zeros((h,w))

for i in range(h):
    for j in range(w):
        promedio=np.mean(image[i,j,:])
        lena_gris[i,j]=promedio

plt.imshow(lena_gris, cmap = "gray")

"""Por último, vamos a proceder a "binarizar" la imagen. Es decir, vamos a setear en 1 TODOS los pixeles donde la intensidad (es decir, el valor del pixel) sea mayor a 200. El resto, lo seteamos a 0. Mostrar el resultado."""

binario= (lena_gris> 200).astype(int)
plt.imshow(binario, cmap="gray")

"""# Análisis de datos

`boston.csv` es un archivo csv ampliamente utilizado como 'juguete' en proyectos de Machine Learning. Para descargarlo, corra la siguiente celda.
"""

!wget https://raw.githubusercontent.com/vincentarelbundock/Rdatasets/master/csv/MASS/Boston.csv

"""Lea el archivo csv (sin `pandas` pero se puede usar `csv`) y quedese con todas las columnas que son numericas. Inspeccionarlo puede hacer el trabajo bastante facil.

Nota: Aunque `numpy` tenga una libreria para leer archivos, en este caso no no es útil por que todas las columas constan de diferentes tipo de dato y ademas el encabezado es `string`.
"""

import csv
with open('Boston.csv', newline='') as csvfile:
  reader= csv.reader(csvfile)
  for i in reader:
    print(i)
print(reader)

"""Una vez procesado el archivo csv, proceda a convertirlo en una matriz de `numpy`."""

with open("Boston.csv") as file_name:
    file_read = csv.reader(file_name)
    lista = list(file_read)
matriz=np.array(lista)

matriz

"""Reporte el promedio de todas las columnas."""

for i in range(1,len(matriz[0])):
  column =matriz[1:,i]

  column_array = np.array(column, dtype=float)

  column_sum = np.mean(column_array)
  print(column_sum)

"""Reporte la división entre una columna y otra (a elección cuales)"""

column1=matriz[1:,2]
column2=matriz[1:,3]

column_array1 = np.array(column1, dtype=float)
column_array2 = np.array(column2, dtype=float)

divicion = (np.sum(column_array1))/(np.sum(column_array2))
print(divicion)